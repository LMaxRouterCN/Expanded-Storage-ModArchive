# .github/workflows/mod_uploader.yml
name: Mod File Uploader - FINAL

on:
  issues:
    types: [opened]

env:
  MAX_FILE_SIZE: 524288000  # 500MB

jobs:
  process-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Parse issue fields
        id: parse_fields
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            
            console.log('=== è°ƒè¯•ä¿¡æ¯ ===');
            console.log('æ ‡é¢˜:', title);
            console.log('æ­£æ–‡é¢„è§ˆ (å‰300å­—ç¬¦):', body.substring(0, 300));
            console.log('=== è°ƒè¯•ç»“æŸ ===');
            
            // 1. éªŒè¯æ¨¡æ¿ä½¿ç”¨
            const usesTemplate = 
              title.includes('[UPLOAD]') || 
              body.includes('é‡è¦æç¤º') || 
              body.includes('æ¨¡ç»„åŠ è½½å™¨');
            
            if (!usesTemplate) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ **æœªä½¿ç”¨æ­£ç¡®æ¨¡æ¿**\n\nè¯·ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ­¥éª¤:\n1. ç‚¹å‡»ä»“åº“çš„"Issues"æ ‡ç­¾\n2. ç‚¹å‡»ç»¿è‰²çš„"New Issue"æŒ‰é’®\n3. **é€‰æ‹©"ä¸Šä¼ æ¨¡ç»„æ–‡ä»¶"æ¨¡æ¿** (ä¸æ˜¯"Open a blank issue")\n4. æŒ‰ç…§æ¨¡æ¿æŒ‡å¼•æ“ä½œ`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid template usage');
              return;
            }
            
            // 2. æå–å¿…å¡«å­—æ®µ
            const mcVersionMatch = body.match(/-\s*MCç‰ˆæœ¬\s*:\s*(.+)/i);
            const loaderMatch = body.match(/-\s*æ¨¡ç»„åŠ è½½å™¨\s*:\s*\[x\]\s*(forge|neoforge|fabric)/i);
            const modVersionMatch = body.match(/-\s*æ¨¡ç»„ç‰ˆæœ¬\s*:\s*(.+)/i);
            
            let mcVersion = mcVersionMatch ? mcVersionMatch[1].trim() : '';
            let loader = loaderMatch ? loaderMatch[1].trim().toLowerCase() : '';
            let modVersion = modVersionMatch ? modVersionMatch[1].trim() : '';
            
            console.log('æå–å­—æ®µ:');
            console.log('MCç‰ˆæœ¬:', mcVersion);
            console.log('åŠ è½½å™¨:', loader);
            console.log('æ¨¡ç»„ç‰ˆæœ¬:', modVersion);
            
            // 3. éªŒè¯å¿…å¡«å­—æ®µ
            const missingFields = [];
            if (!mcVersion) missingFields.push('MCç‰ˆæœ¬');
            if (!loader) missingFields.push('æ¨¡ç»„åŠ è½½å™¨');
            if (!modVersion) missingFields.push('æ¨¡ç»„ç‰ˆæœ¬');
            
            if (missingFields.length > 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ **ç¼ºå°‘å¿…å¡«å­—æ®µ**\n\nè¯·è¡¥å……ä»¥ä¸‹ä¿¡æ¯:\n` + 
                      missingFields.map(field => `- [ ] ${field}`).join('\n') + 
                      `\n\nä¿®æ”¹Issueåé‡æ–°æäº¤`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Missing required fields');
              return;
            }
            
            // 4. æ¸…ç†å­—æ®µå€¼ (åˆ›å»ºåˆæ³•tag)
            const cleanTagPart = (str) => {
              return str.toLowerCase()
                .replace(/[^a-z0-9.+_-]/g, '-') // æ›¿æ¢éæ³•å­—ç¬¦
                .replace(/-+/g, '-')            // åˆå¹¶è¿ç»­-
                .replace(/^-+|-+$/g, '');       // ç§»é™¤å‰å-
            };
            
            const cleanMcVersion = cleanTagPart(mcVersion);
            const cleanLoader = cleanTagPart(loader);
            const cleanModVersion = cleanTagPart(modVersion);
            
            // 5. ç”Ÿæˆtag (v<mcç‰ˆæœ¬>-<åŠ è½½å™¨>-<æ¨¡ç»„ç‰ˆæœ¬>)
            let releaseTag = `v${cleanMcVersion}-${cleanLoader}-${cleanModVersion}`;
            console.log('ç”Ÿæˆçš„Release Tag:', releaseTag);
            
            // 6. ä»æ­£æ–‡æå–æ‰€æœ‰URL
            const urls = [];
            
            // ç­–ç•¥1: åŒ¹é…Markdownå›¾ç‰‡/é“¾æ¥è¯­æ³•
            const markdownRegex = /!\[[^\]]*\]\(([^)]+?)\)|\[[^\]]*\]\(([^)]+?)\)/g;
            let urlMatch;
            while ((urlMatch = markdownRegex.exec(body)) !== null) {
              const url = urlMatch[1] || urlMatch[2];
              if (url && url.includes('.zip')) {
                urls.push(url);
              }
            }
            
            // ç­–ç•¥2: åŒ¹é…çº¯URL
            const urlRegex = /(https?:\/\/[^\s)]+?\.zip[^\s)]*)/ig;
            const pureUrls = body.match(urlRegex) || [];
            urls.push(...pureUrls);
            
            // å»é‡
            const uniqueUrls = [...new Set(urls)];
            console.log('æ£€æµ‹åˆ°çš„URL:', uniqueUrls);
            
            if (uniqueUrls.length === 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ **æœªæ£€æµ‹åˆ°.zipæ–‡ä»¶**\n\n**æ­£ç¡®ä¸Šä¼ æ­¥éª¤**:\n1. å°†æ–‡ä»¶é‡å‘½åä¸º \`æ–‡ä»¶å.jar.zip\`\n2. **ç›´æ¥æ‹–æ‹½**æ–‡ä»¶åˆ°è¯„è®ºæ¡† (ä¸æ˜¯ç‚¹å‡»æŒ‰é’®)\n3. **ç­‰å¾…ä¸Šä¼ å®Œæˆ** (çœ‹åˆ°æ–‡ä»¶åå‡ºç°åœ¨è¯„è®ºæ¡†)\n4. æäº¤Issue`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('No zip URLs found');
              return;
            }
            
            // 7. é€‰æ‹©ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„.zip URL
            let fileUrl = uniqueUrls.find(url => url.toLowerCase().includes('.jar.zip')) || uniqueUrls[0];
            fileUrl = fileUrl.trim();
            
            // 8. ä¿®å¤ç‰¹æ®Šå­—ç¬¦
            fileUrl = fileUrl
              .replace(/%2B/g, '+')
              .replace(/%20/g, ' ')
              .replace(/&amp;/g, '&')
              .replace(/&#43;/g, '+');
            
            // 9. å¤„ç†GitHubä»£ç†URL
            if (fileUrl.includes('user-attachments.githubusercontent.com')) {
              fileUrl = fileUrl.replace(
                'https://user-attachments.githubusercontent.com/',
                'https://github.com/'
              );
            } else if (fileUrl.includes('private-user-attachments')) {
              fileUrl = fileUrl.replace(
                'https://private-user-attachments.githubusercontent.com/',
                'https://github.com/'
              );
            }
            
            // 10. æå–æ–‡ä»¶å
            let originalName = '';
            try {
              const urlObj = new URL(fileUrl, 'https://github.com');
              const params = new URLSearchParams(urlObj.search);
              
              if (params.has('name')) {
                originalName = decodeURIComponent(params.get('name'));
              } else {
                const path = urlObj.pathname;
                originalName = decodeURIComponent(path.substring(path.lastIndexOf('/') + 1));
              }
            } catch (e) {
              console.log('URLè§£æå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•');
              const match = fileUrl.match(/\/([^\/?]+?)(?:\?|$)/);
              originalName = match ? match[1].replace(/\+/g, ' ') : 'unknown.zip';
            }
            
            // 11. æ™ºèƒ½æ–‡ä»¶åä¿®å¤
            let cleanedName = originalName;
            const lowerName = cleanedName.toLowerCase();
            
            if (!lowerName.endsWith('.zip')) {
              cleanedName += '.zip';
            }
            
            if (!lowerName.includes('.jar')) {
              cleanedName = cleanedName.replace(/\.zip$/, '.jar.zip');
            } else {
              cleanedName = cleanedName.replace(/\.jar\.zip$/i, '.jar.zip');
            }
            
            console.log('ä¿®å¤åçš„æ–‡ä»¶å:', cleanedName);
            
            // 12. è®¾ç½®æ­£ç¡®çš„JARæ–‡ä»¶å
            let jarName = cleanedName;
            if (jarName.toLowerCase().endsWith('.jar.zip')) {
              jarName = jarName.substring(0, jarName.length - 4);
            } else if (jarName.toLowerCase().endsWith('.zip')) {
              jarName = jarName.substring(0, jarName.length - 4) + '.jar';
            }
            
            console.log('JARæ–‡ä»¶å:', jarName);
            
            // 13. è®¾ç½®è¾“å‡º
            core.setOutput('file_url', fileUrl);
            core.setOutput('original_name', cleanedName);
            core.setOutput('jar_name', jarName);
            core.setOutput('mc_version', mcVersion);
            core.setOutput('loader', loader);
            core.setOutput('mod_version', modVersion);
            core.setOutput('release_tag', releaseTag);
            core.setOutput('debug_urls', uniqueUrls.join('\n'));

      - name: Download file
        env:
          FILE_URL: ${{ steps.parse_fields.outputs.file_url }}
          OUTPUT_NAME: ${{ steps.parse_fields.outputs.original_name }}
        run: |
          echo "ä¸‹è½½URL: $FILE_URL"
          echo "ä¿å­˜ä¸º: $OUTPUT_NAME"
          
          SAFE_NAME=$(echo "$OUTPUT_NAME" | tr -cd 'a-zA-Z0-9._-')
          [ -z "$SAFE_NAME" ] && SAFE_NAME="mod.jar.zip"
          
          curl -L \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/octet-stream" \
            --retry 3 \
            --retry-delay 5 \
            --max-time 300 \
            --output "$SAFE_NAME" \
            "$FILE_URL"
          
          if [ ! -f "$SAFE_NAME" ]; then
            echo "âŒ ä¸‹è½½å¤±è´¥"
            ls -la
            exit 1
          fi
          
          mv "$SAFE_NAME" "$OUTPUT_NAME"
          echo "ä¸‹è½½å®Œæˆ: $(stat -c%s "$OUTPUT_NAME") å­—èŠ‚"

      - name: Verify ZIP integrity
        id: verify_zip
        run: |
          FILE="${{ steps.parse_fields.outputs.original_name }}"
          
          size=$(stat -c%s "$FILE")
          echo "æ–‡ä»¶å¤§å°: $size å­—èŠ‚"
          
          if [ "$size" -gt "${{ env.MAX_FILE_SIZE }}" ]; then
            echo "âŒ æ–‡ä»¶è¶…è¿‡500MBé™åˆ¶"
            exit 1
          fi
          
          if [ "$size" -eq 0 ]; then
            echo "âŒ ç©ºæ–‡ä»¶"
            exit 1
          fi
          
          if ! unzip -t "$FILE" > /dev/null 2>&1; then
            echo "âŒ æ— æ•ˆçš„ZIPæ–‡ä»¶"
            unzip -t "$FILE" 2>&1
            exit 1
          fi
          
          sha256=$(sha256sum "$FILE" | awk '{print $1}')
          echo "sha256_hash=$sha256" >> $GITHUB_OUTPUT
          echo "çŸ­å“ˆå¸Œ: ${sha256:0:8}"

      - name: Check duplicates
        id: check_duplicates
        uses: actions/github-script@v7
        with:
          script: |
            const sha256 = '${{ steps.verify_zip.outputs.sha256_hash }}';
            const shortHash = sha256.substring(0, 8);
            const releaseTag = '${{ steps.parse_fields.outputs.release_tag }}';
            
            try {
              // æ£€æŸ¥é‡å¤
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `sha256-${sha256}`
              });
              
              // è·å–ç°æœ‰æ–‡ä»¶
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const release = releases.data.find(r => r.tag_name === `sha256-${sha256}`);
              if (release) {
                const jar = release.assets.find(a => a.name.toLowerCase().endsWith('.jar'));
                if (jar) {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: `ğŸ”„ **é‡å¤æ–‡ä»¶**\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨:\nğŸ“¥ [${jar.name}](${jar.browser_download_url})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\``
                  });
                  await github.rest.issues.update({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'closed'
                  });
                  core.setOutput('duplicate', 'true');
                  core.setOutput('download_url', jar.browser_download_url);
                  core.setOutput('short_hash', shortHash);
                  return;
                }
              }
            } catch (error) {
              if (error.status !== 404) {
                console.log('æ£€æŸ¥é‡å¤æ—¶å‡ºé”™:', error.message);
              }
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒtagçš„Release
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: releaseTag
              });
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âš ï¸ **ç›¸åŒç‰ˆæœ¬å·²å­˜åœ¨**\n\nç›¸åŒç‰ˆæœ¬(\`${releaseTag}\`)çš„æ–‡ä»¶å·²å­˜åœ¨ã€‚å¦‚æœè¿™æ˜¯æ›´æ–°ï¼Œè¯·åœ¨æ¨¡ç»„ç‰ˆæœ¬å­—æ®µæ·»åŠ åç¼€(å¦‚-beta.2)ã€‚`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Duplicate version tag');
              return;
            } catch (error) {
              if (error.status !== 404) {
                console.log('æ£€æŸ¥ç‰ˆæœ¬æ ‡ç­¾æ—¶å‡ºé”™:', error.message);
              }
            }
            
            core.setOutput('duplicate', 'false');
            core.setOutput('short_hash', shortHash);

      - name: Rename to JAR
        if: steps.check_duplicates.outputs.duplicate == 'false'
        run: |
          mv "${{ steps.parse_fields.outputs.original_name }}" "${{ steps.parse_fields.outputs.jar_name }}"
          echo "é‡å‘½åä¸ºJARå®Œæˆ: ${{ steps.parse_fields.outputs.jar_name }}"

      - name: Create release
        id: create_release
        if: steps.check_duplicates.outputs.duplicate == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { createReadStream } = require('fs');
            const { basename } = require('path');
            
            const releaseTag = '${{ steps.parse_fields.outputs.release_tag }}';
            const releaseName = releaseTag; // ç›´æ¥ä½¿ç”¨tagä½œä¸ºåç§°
            const jarFile = '${{ steps.parse_fields.outputs.jar_name }}';
            const jarName = basename(jarFile);
            const fileSize = fs.statSync(jarFile).size;
            
            const timestamp = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '');
            const mcVersion = '${{ steps.parse_fields.outputs.mc_version }}';
            const loader = '${{ steps.parse_fields.outputs.loader }}';
            const modVersion = '${{ steps.parse_fields.outputs.mod_version }}';
            const sha256 = '${{ steps.verify_zip.outputs.sha256_hash }}';
            const shortHash = sha256.substring(0, 8);
            
            // Releaseæ­£æ–‡ (æ—¶é—´æˆ³æ”¾åœ¨æœ«å°¾)
            const body = `âœ… ä¸Šä¼ è‡ª Issue #${context.issue.number}\n\n` +
                         `ğŸ“¦ **è¯¦ç»†ä¿¡æ¯**\n` +
                         `- MCç‰ˆæœ¬: ${mcVersion}\n` +
                         `- åŠ è½½å™¨: ${loader}\n` +
                         `- æ¨¡ç»„ç‰ˆæœ¬: ${modVersion}\n` +
                         `- æ–‡ä»¶å“ˆå¸Œ: ${shortHash}...\n\n` +
                         `âš ï¸ **æ³¨æ„**: ä»…ä»“åº“ç®¡ç†å‘˜å¯åˆ é™¤æ­¤æ–‡ä»¶\n\n` +
                         `ğŸ“… ä¸Šä¼ æ—¶é—´: ${timestamp}`;
            
            try {
              // åˆ›å»ºRelease
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: releaseTag,
                name: releaseName,
                body: body,
                draft: false,
                prerelease: false
              });
              
              // ä¸Šä¼ æ–‡ä»¶
              const asset = await github.rest.repos.uploadReleaseAsset({
                url: release.data.upload_url,
                headers: {
                  'content-length': fileSize,
                  'content-type': 'application/java-archive'
                },
                name: jarName,
                 createReadStream(jarFile)
              });
              
              core.setOutput('release_url', release.data.html_url);
              core.setOutput('download_url', asset.data.browser_download_url);
            } catch (error) {
              console.error('åˆ›å»ºReleaseå¤±è´¥:', error);
              core.setFailed(`ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
            }

      - name: Comment success
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.create_release.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = '${{ steps.create_release.outputs.download_url }}';
            const releaseUrl = '${{ steps.create_release.outputs.release_url }}';
            const shortHash = '${{ steps.check_duplicates.outputs.short_hash }}';
            const releaseTag = '${{ steps.parse_fields.outputs.release_tag }}';
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **ä¸Šä¼ æˆåŠŸ!**\n\nğŸ·ï¸ **ç‰ˆæœ¬**: \`${releaseTag}\`\nğŸ“¥ [ä¸‹è½½æ–‡ä»¶](${downloadUrl})\nğŸ“¦ [æ‰€æœ‰æ–‡ä»¶](${releaseUrl})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\``
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Cleanup
        if: always()
        run: |
          echo "æ¸…ç†æ–‡ä»¶..."
          rm -f *.zip *.jar || true
          echo "æ¸…ç†å®Œæˆ"

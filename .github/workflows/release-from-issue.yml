# .github/workflows/mod_uploader.yml
name: Mod File Uploader - FINAL

on:
  issues:
    types: [opened]

env:
  MAX_FILE_SIZE: 524288000  # 500MB

jobs:
  process-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Parse issue fields
        id: parse_fields
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            
            console.log('=== è°ƒè¯•ä¿¡æ¯ ===');
            console.log('æ ‡é¢˜:', title);
            console.log('å®Œæ•´æ­£æ–‡ (ç”¨äºè°ƒè¯•):', body);
            console.log('=== è°ƒè¯•ç»“æŸ ===');
            
            // 1. éªŒè¯æ¨¡æ¿ä½¿ç”¨
            const usesTemplate = 
              title.includes('[UPLOAD]') || 
              body.includes('é‡è¦æç¤º') || 
              body.includes('æ¨¡ç»„åŠ è½½å™¨');
            
            if (!usesTemplate) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ **æœªä½¿ç”¨æ­£ç¡®æ¨¡æ¿**\n\nè¯·ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ­¥éª¤:\n1. ç‚¹å‡»ä»“åº“çš„"Issues"æ ‡ç­¾\n2. ç‚¹å‡»ç»¿è‰²çš„"New Issue"æŒ‰é’®\n3. **é€‰æ‹©"ä¸Šä¼ æ¨¡ç»„æ–‡ä»¶"æ¨¡æ¿** (ä¸æ˜¯"Open a blank issue")\n4. æŒ‰ç…§æ¨¡æ¿æŒ‡å¼•æ“ä½œ`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid template usage');
              return;
            }
            
            // 2. æå–å­—æ®µ - é€‚é…GitHubå®é™…æ¸²æŸ“æ ¼å¼
            let mcVersion = '';
            let loader = '';
            let modVersion = '';
            
            // æ–¹æ³•1: åŒ¹é…###æ ‡é¢˜æ ¼å¼ (GitHubå®é™…æ¸²æŸ“æ ¼å¼)
            const sections = body.split('### ');
            for (const section of sections) {
              if (section.startsWith('MCç‰ˆæœ¬')) {
                mcVersion = section.split('\n')[1]?.trim() || '';
              } else if (section.startsWith('æ¨¡ç»„åŠ è½½å™¨')) {
                loader = section.split('\n')[1]?.trim().toLowerCase() || '';
              } else if (section.startsWith('æ¨¡ç»„ç‰ˆæœ¬')) {
                modVersion = section.split('\n')[1]?.trim() || '';
              }
            }
            
            console.log('æå–ç»“æœ (æ–¹æ³•1):');
            console.log('MCç‰ˆæœ¬:', mcVersion);
            console.log('åŠ è½½å™¨:', loader);
            console.log('æ¨¡ç»„ç‰ˆæœ¬:', modVersion);
            
            // æ–¹æ³•2: å¤‡ç”¨æ­£åˆ™ (å…¼å®¹å…¶ä»–æ ¼å¼)
            if (!mcVersion || !loader || !modVersion) {
              const mcRegex = /###\s*MCç‰ˆæœ¬\s*\n\s*([^\n]+)/i;
              const loaderRegex = /###\s*æ¨¡ç»„åŠ è½½å™¨\s*\n\s*([^\n]+)/i;
              const modRegex = /###\s*æ¨¡ç»„ç‰ˆæœ¬\s*\n\s*([^\n]+)/i;
              
              const mcMatch = body.match(mcRegex);
              const loaderMatch = body.match(loaderRegex);
              const modMatch = body.match(modRegex);
              
              if (mcMatch) mcVersion = mcMatch[1].trim();
              if (loaderMatch) loader = loaderMatch[1].trim().toLowerCase();
              if (modMatch) modVersion = modMatch[1].trim();
            }
            
            console.log('æœ€ç»ˆæå–ç»“æœ:');
            console.log('MCç‰ˆæœ¬:', mcVersion);
            console.log('åŠ è½½å™¨:', loader);
            console.log('æ¨¡ç»„ç‰ˆæœ¬:', modVersion);
            
            // 3. éªŒè¯å¿…å¡«å­—æ®µ
            const missingFields = [];
            if (!mcVersion) missingFields.push('MCç‰ˆæœ¬');
            if (!loader) missingFields.push('æ¨¡ç»„åŠ è½½å™¨');
            if (!modVersion) missingFields.push('æ¨¡ç»„ç‰ˆæœ¬');
            
            if (missingFields.length > 0) {
              let errorMessage = `âŒ **ç¼ºå°‘å¿…å¡«å­—æ®µ**\n\næ£€æµ‹åˆ°çš„å­—æ®µå€¼:\n`;
              errorMessage += `- MCç‰ˆæœ¬: \`${mcVersion || 'æœªæ£€æµ‹åˆ°'}\`\n`;
              errorMessage += `- æ¨¡ç»„åŠ è½½å™¨: \`${loader || 'æœªæ£€æµ‹åˆ°'}\`\n`;
              errorMessage += `- æ¨¡ç»„ç‰ˆæœ¬: \`${modVersion || 'æœªæ£€æµ‹åˆ°'}\`\n\n`;
              
              errorMessage += `**å¯èƒ½åŸå› **:\n`;
              if (!loader) errorMessage += `- GitHubä¸‹æ‹‰é€‰æ‹©æ¡†æœªè¢«æ­£ç¡®è¯†åˆ«\n`;
              errorMessage += `\n**è§£å†³æ–¹æ¡ˆ**:\n`;
              errorMessage += `1. ç¼–è¾‘Issueï¼Œåœ¨"æ¨¡ç»„åŠ è½½å™¨"å­—æ®µ**æ‰‹åŠ¨è¾“å…¥** (forge/neoforge/fabric)\n`;
              errorMessage += `2. ç¡®ä¿æ¯ä¸ªå­—æ®µ**å•ç‹¬ä¸€è¡Œ** (ä¸è¦åˆå¹¶)\n`;
              errorMessage += `3. é‡æ–°æäº¤Issue`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorMessage
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Missing required fields');
              return;
            }
            
            // 4. éªŒè¯åŠ è½½å™¨å€¼
            const validLoaders = ['forge', 'neoforge', 'fabric'];
            if (!validLoaders.includes(loader)) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ **æ— æ•ˆçš„æ¨¡ç»„åŠ è½½å™¨**\n\næ£€æµ‹åˆ°: \`${loader}\`\n\n**å¿…é¡»é€‰æ‹©ä»¥ä¸‹ä¹‹ä¸€**:\n- forge\n- neoforge\n- fabric\n\nè¯·ç¼–è¾‘Issueä¿®æ­£åé‡æ–°æäº¤`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid loader value');
              return;
            }
            
            // 5. æ¸…ç†å­—æ®µå€¼ (åˆ›å»ºåˆæ³•tag)
            const cleanTagPart = (str) => {
              return str.toLowerCase()
                .replace(/[^a-z0-9.+_-]/g, '-') // æ›¿æ¢éæ³•å­—ç¬¦
                .replace(/\+/g, '-')            // ç‰¹æ®Šå¤„ç†+å·
                .replace(/-+/g, '-')            // åˆå¹¶è¿ç»­-
                .replace(/^-+|-+$/g, '');       // ç§»é™¤å‰å-
            };
            
            const cleanMcVersion = cleanTagPart(mcVersion);
            const cleanLoader = cleanTagPart(loader);
            const cleanModVersion = cleanTagPart(modVersion);
            
            // 6. ç”Ÿæˆtag (v<mcç‰ˆæœ¬>-<åŠ è½½å™¨>-<æ¨¡ç»„ç‰ˆæœ¬>)
            let releaseTag = `v${cleanMcVersion}-${cleanLoader}-${cleanModVersion}`;
            console.log('ç”Ÿæˆçš„Release Tag:', releaseTag);
            
            // 7. æå–é™„ä»¶URL - ä¿®å¤ç©ºæ ¼é—®é¢˜
            const urls = [];
            
            // åŒ¹é…é™„ä»¶é“¾æ¥ (å¤„ç†æœ«å°¾ç©ºæ ¼)
            const attachmentRegex = /\[([^\]]+?)\]\((https?:\/\/[^\s]+?\.zip[^\s]*?)\s*\)/ig;
            let urlMatch;
            while ((urlMatch = attachmentRegex.exec(body)) !== null) {
              const url = urlMatch[2].trim();
              urls.push(url);
            }
            
            // å¤‡ç”¨: åŒ¹é…çº¯URL
            const urlRegex = /(https?:\/\/[^\s)]+?\.zip[^\s)]*)/ig;
            const pureUrls = body.match(urlRegex) || [];
            urls.push(...pureUrls);
            
            // å»é‡
            const uniqueUrls = [...new Set(urls)];
            console.log('æ£€æµ‹åˆ°çš„URL:', uniqueUrls);
            
            if (uniqueUrls.length === 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ **æœªæ£€æµ‹åˆ°.zipæ–‡ä»¶**\n\n**æ­£ç¡®ä¸Šä¼ æ­¥éª¤**:\n1. å°†æ–‡ä»¶é‡å‘½åä¸º \`æ–‡ä»¶å.jar.zip\`\n2. **ç›´æ¥æ‹–æ‹½**æ–‡ä»¶åˆ°è¯„è®ºæ¡†\n3. **ç­‰å¾…ä¸Šä¼ å®Œæˆ** (çœ‹åˆ°æ–‡ä»¶åå‡ºç°åœ¨è¯„è®ºæ¡†)\n4. æäº¤Issue\n\nâ„¹ï¸ æ‚¨çš„æ–‡ä»¶åº”æ˜¾ç¤ºä¸ºç±»ä¼¼:\n\`[æ–‡ä»¶å.jar.zip](https://...)\``
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('No zip URLs found');
              return;
            }
            
            // 8. é€‰æ‹©ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„.zip URL
            let fileUrl = uniqueUrls.find(url => url.toLowerCase().includes('.jar.zip')) || uniqueUrls[0];
            fileUrl = fileUrl.trim();
            
            // 9. ä¿®å¤ç‰¹æ®Šå­—ç¬¦
            fileUrl = fileUrl
              .replace(/%2B/g, '+')
              .replace(/%20/g, ' ')
              .replace(/&amp;/g, '&')
              .replace(/&#43;/g, '+')
              .replace(/\s+$/, ''); // ç§»é™¤æœ«å°¾ç©ºæ ¼
            
            console.log('å¤„ç†åçš„æ–‡ä»¶URL:', fileUrl);
            
            // 10. æå–æ–‡ä»¶å
            let originalName = '';
            try {
              // ä»URLè·å–åŸå§‹æ–‡ä»¶å
              const urlObj = new URL(fileUrl, 'https://github.com');
              const path = urlObj.pathname;
              originalName = decodeURIComponent(path.substring(path.lastIndexOf('/') + 1));
              
              // ä»URLå‚æ•°è·å– (å¦‚æœå­˜åœ¨)
              const params = new URLSearchParams(urlObj.search);
              if (params.has('name')) {
                originalName = decodeURIComponent(params.get('name'));
              }
            } catch (e) {
              console.log('URLè§£æå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•');
              const match = fileUrl.match(/\/([^\/?]+?)(?:\?|$)/);
              originalName = match ? decodeURIComponent(match[1].replace(/\+/g, ' ')) : 'unknown.zip';
            }
            
            // 11. æ™ºèƒ½æ–‡ä»¶åä¿®å¤
            let cleanedName = originalName;
            const lowerName = cleanedName.toLowerCase();
            
            if (!lowerName.endsWith('.zip')) {
              cleanedName += '.zip';
            }
            
            if (!lowerName.includes('.jar')) {
              cleanedName = cleanedName.replace(/\.zip$/, '.jar.zip');
            } else {
              cleanedName = cleanedName.replace(/\.jar\.zip$/i, '.jar.zip');
            }
            
            console.log('ä¿®å¤åçš„æ–‡ä»¶å:', cleanedName);
            
            // 12. è®¾ç½®æ­£ç¡®çš„JARæ–‡ä»¶å
            let jarName = cleanedName;
            if (jarName.toLowerCase().endsWith('.jar.zip')) {
              jarName = jarName.substring(0, jarName.length - 4); // ç§»é™¤.zip
            } else if (jarName.toLowerCase().endsWith('.zip')) {
              jarName = jarName.substring(0, jarName.length - 4) + '.jar';
            }
            
            console.log('JARæ–‡ä»¶å:', jarName);
            
            // 13. è®¾ç½®è¾“å‡º
            core.setOutput('file_url', fileUrl);
            core.setOutput('original_name', cleanedName);
            core.setOutput('jar_name', jarName);
            core.setOutput('mc_version', mcVersion);
            core.setOutput('loader', loader);
            core.setOutput('mod_version', modVersion);
            core.setOutput('release_tag', releaseTag);
            core.setOutput('debug_urls', uniqueUrls.join('\n'));

      - name: Download file
        env:
          FILE_URL: ${{ steps.parse_fields.outputs.file_url }}
          OUTPUT_NAME: ${{ steps.parse_fields.outputs.original_name }}
        run: |
          echo "ä¸‹è½½URL: $FILE_URL"
          echo "ä¿å­˜ä¸º: $OUTPUT_NAME"
          
          SAFE_NAME=$(echo "$OUTPUT_NAME" | tr -cd 'a-zA-Z0-9._-')
          [ -z "$SAFE_NAME" ] && SAFE_NAME="mod.jar.zip"
          
          curl -L \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/octet-stream" \
            --retry 3 \
            --retry-delay 5 \
            --max-time 300 \
            --output "$SAFE_NAME" \
            "$FILE_URL"
          
          if [ ! -f "$SAFE_NAME" ]; then
            echo "âŒ ä¸‹è½½å¤±è´¥"
            ls -la
            exit 1
          fi
          
          mv "$SAFE_NAME" "$OUTPUT_NAME"
          echo "ä¸‹è½½å®Œæˆ: $(stat -c%s "$OUTPUT_NAME") å­—èŠ‚"

      - name: Verify ZIP integrity
        id: verify_zip
        run: |
          FILE="${{ steps.parse_fields.outputs.original_name }}"
          
          # æ£€æŸ¥æ–‡ä»¶å¤§å°
          size=$(stat -c%s "$FILE")
          echo "æ–‡ä»¶å¤§å°: $size å­—èŠ‚"
          
          if [ "$size" -gt "${{ env.MAX_FILE_SIZE }}" ]; then
            echo "âŒ æ–‡ä»¶è¶…è¿‡500MBé™åˆ¶"
            exit 1
          fi
          
          if [ "$size" -eq 0 ]; then
            echo "âŒ ç©ºæ–‡ä»¶"
            exit 1
          fi
          
          # éªŒè¯ZIP
          if ! unzip -t "$FILE" > /dev/null 2>&1; then
            echo "âŒ æ— æ•ˆçš„ZIPæ–‡ä»¶"
            unzip -t "$FILE" 2>&1
            exit 1
          fi
          
          # è®¡ç®—SHA256
          sha256=$(sha256sum "$FILE" | awk '{print $1}')
          echo "sha256_hash=$sha256" >> $GITHUB_OUTPUT
          echo "çŸ­å“ˆå¸Œ: ${sha256:0:8}"

      - name: Check duplicates
        id: check_duplicates
        uses: actions/github-script@v7
        with:
          script: |
            const sha256 = '${{ steps.verify_zip.outputs.sha256_hash }}';
            const shortHash = sha256.substring(0, 8);
            const releaseTag = '${{ steps.parse_fields.outputs.release_tag }}';
            
            try {
              // æ£€æŸ¥é‡å¤
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `sha256-${sha256}`
              });
              
              // è·å–ç°æœ‰æ–‡ä»¶
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const release = releases.data.find(r => r.tag_name === `sha256-${sha256}`);
              if (release) {
                const jar = release.assets.find(a => a.name.toLowerCase().endsWith('.jar'));
                if (jar) {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: `ğŸ”„ **é‡å¤æ–‡ä»¶**\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨:\nğŸ“¥ [${jar.name}](${jar.browser_download_url})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\``
                  });
                  await github.rest.issues.update({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'closed'
                  });
                  core.setOutput('duplicate', 'true');
                  core.setOutput('download_url', jar.browser_download_url);
                  core.setOutput('short_hash', shortHash);
                  return;
                }
              }
            } catch (error) {
              if (error.status !== 404) {
                console.log('æ£€æŸ¥é‡å¤æ—¶å‡ºé”™:', error.message);
              }
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒtagçš„Release
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: releaseTag
              });
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âš ï¸ **ç›¸åŒç‰ˆæœ¬å·²å­˜åœ¨**\n\nç›¸åŒç‰ˆæœ¬(\`${releaseTag}\`)çš„æ–‡ä»¶å·²å­˜åœ¨ã€‚å¦‚æœè¿™æ˜¯æ›´æ–°ï¼Œè¯·åœ¨æ¨¡ç»„ç‰ˆæœ¬å­—æ®µæ·»åŠ åç¼€(å¦‚-beta.2)ã€‚`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Duplicate version tag');
              return;
            } catch (error) {
              if (error.status !== 404) {
                console.log('æ£€æŸ¥ç‰ˆæœ¬æ ‡ç­¾æ—¶å‡ºé”™:', error.message);
              }
            }
            
            core.setOutput('duplicate', 'false');
            core.setOutput('short_hash', shortHash);

      - name: Rename to JAR
        if: steps.check_duplicates.outputs.duplicate == 'false'
        run: |
          mv "${{ steps.parse_fields.outputs.original_name }}" "${{ steps.parse_fields.outputs.jar_name }}"
          echo "é‡å‘½åä¸ºJARå®Œæˆ: ${{ steps.parse_fields.outputs.jar_name }}"

      - name: Create release
        id: create_release
        if: steps.check_duplicates.outputs.duplicate == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { createReadStream } = require('fs');
            const { basename } = require('path');
            
            const releaseTag = '${{ steps.parse_fields.outputs.release_tag }}';
            const releaseName = releaseTag;
            const jarFile = '${{ steps.parse_fields.outputs.jar_name }}';
            const jarName = basename(jarFile);
            const fileSize = fs.statSync(jarFile).size;
            
            const timestamp = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '');
            const body = `âœ… ä¸Šä¼ è‡ª Issue #${context.issue.number}\n\n` +
                         `ğŸ“¦ **è¯¦ç»†ä¿¡æ¯**\n` +
                         `- MCç‰ˆæœ¬: ${{ steps.parse_fields.outputs.mc_version }}\n` +
                         `- åŠ è½½å™¨: ${{ steps.parse_fields.outputs.loader }}\n` +
                         `- æ¨¡ç»„ç‰ˆæœ¬: ${{ steps.parse_fields.outputs.mod_version }}\n` +
                         `- æ–‡ä»¶å“ˆå¸Œ: ${{ steps.check_duplicates.outputs.short_hash }}...\n\n` +
                         `âš ï¸ **æ³¨æ„**: ä»…ä»“åº“ç®¡ç†å‘˜å¯åˆ é™¤æ­¤æ–‡ä»¶\n\n` +
                         `ğŸ“… ä¸Šä¼ æ—¶é—´: ${timestamp}`;
            
            try {
              // åˆ›å»ºRelease
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: releaseTag,
                name: releaseName,
                body: body,
                draft: false,
                prerelease: false
              });
              
              // ä¸Šä¼ æ–‡ä»¶ - å…³é”®ä¿®å¤ï¼šæ·»åŠ dataå‚æ•°å
              const asset = await github.rest.repos.uploadReleaseAsset({
                url: release.data.upload_url,
                headers: {
                  'content-length': fileSize,
                  'content-type': 'application/java-archive'
                },
                name: jarName,
                data: createReadStream(jarFile) // ä¿®å¤ï¼šæ·»åŠ dataå‚æ•°å
              });
              
              core.setOutput('release_url', release.data.html_url);
              core.setOutput('download_url', asset.data.browser_download_url);
            } catch (error) {
              console.error('åˆ›å»ºReleaseå¤±è´¥:', error);
              core.setFailed(`ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
            }

      - name: Comment success
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.create_release.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = '${{ steps.create_release.outputs.download_url }}';
            const releaseUrl = '${{ steps.create_release.outputs.release_url }}';
            const shortHash = '${{ steps.check_duplicates.outputs.short_hash }}';
            const releaseTag = '${{ steps.parse_fields.outputs.release_tag }}';
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **ä¸Šä¼ æˆåŠŸ!**\n\nğŸ·ï¸ **ç‰ˆæœ¬**: \`${releaseTag}\`\nğŸ“¥ [ä¸‹è½½æ–‡ä»¶](${downloadUrl})\nğŸ“¦ [æ‰€æœ‰æ–‡ä»¶](${releaseUrl})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\``
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Cleanup
        if: always()
        run: |
          echo "æ¸…ç†æ–‡ä»¶..."
          rm -f *.zip *.jar || true
          echo "æ¸…ç†å®Œæˆ"

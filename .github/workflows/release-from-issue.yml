# .github/workflows/mod_uploader.yml
name: Mod File Uploader with Deduplication

on:
  issues:
    types: [opened]

env:
  MAX_FILE_SIZE: 524288000  # 500MB in bytes

jobs:
  process-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Validate issue properly
        id: validate_issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            
            // è°ƒè¯•ä¿¡æ¯
            console.log('Issue title:', title);
            console.log('Issue labels:', issue.labels.map(l => l.name));
            console.log('Issue body preview:', body.substring(0, 200));
            
            // æ–¹æ³•1: æ£€æŸ¥æ ‡é¢˜å‰ç¼€ (æ›´å¯é )
            const hasValidPrefix = title.trim().startsWith('[UPLOAD]');
            
            // æ–¹æ³•2: æ£€æŸ¥æ ‡ç­¾ (å¦‚æœä»“åº“å·²è®¾ç½®æ ‡ç­¾)
            const hasUploadLabel = issue.labels.some(label => 
              label.name.toLowerCase().includes('upload') || 
              label.name.toLowerCase() === 'uploader'
            );
            
            // æ–¹æ³•3: æ£€æŸ¥æ¨¡æ¿ç‰¹å¾
            const hasTemplateMarkers = body.includes('é‡è¦æç¤º') && 
                                      body.includes('é‡å‘½åä¸º **.jar.zip**') &&
                                      body.includes('ç¡®è®¤è¯¥æ–‡ä»¶æ— ç‰ˆæƒé—®é¢˜');
            
            // ä»»ä¸€æ¡ä»¶æ»¡è¶³å³è§†ä¸ºæœ‰æ•ˆ
            if (!hasValidPrefix && !hasUploadLabel && !hasTemplateMarkers) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æ— æ•ˆçš„Issueç±»å‹\n\nè¯·**åŠ¡å¿…**ä½¿ç”¨"ä¸Šä¼ æ¨¡ç»„æ–‡ä»¶"æ¨¡æ¿åˆ›å»ºIssueã€‚åˆ›å»ºæ—¶è¯·åœ¨æ¨¡æ¿é€‰æ‹©é¡µé¢ç‚¹å‡»"ä¸Šä¼ æ¨¡ç»„æ–‡ä»¶"æ¨¡æ¿ï¼Œè€Œä¸æ˜¯ç©ºç™½Issueã€‚`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid issue type - not using template');
              return;
            }
            
            // æå–é™„ä»¶URL (æ”¹è¿›çš„æ­£åˆ™)
            const attachmentRegex = /!\[[^\]]*\]\(([^)]+?\.zip(?:\?[^)]*)?)\)/i;
            const match = body.match(attachmentRegex);
            
            if (!match) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æœªæ£€æµ‹åˆ°æœ‰æ•ˆçš„.zipé™„ä»¶\n\n**æ“ä½œæŒ‡å—**:\n1. å°†.jaræ–‡ä»¶é‡å‘½åä¸º **.jar.zip** (ä¾‹å¦‚: mod.jar â†’ mod.jar.zip)\n2. åœ¨è¯„è®ºæ¡†ä¸­æ‹–å…¥é‡å‘½ååçš„æ–‡ä»¶\n3. **ä¸è¦**ç›´æ¥ä¸Šä¼ .jaræ–‡ä»¶`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('No valid zip attachment found');
              return;
            }
            
            let fileUrl = match[1];
            // ä¿®å¤GitHubé™„ä»¶URL
            if (fileUrl.includes('private-user-attachments')) {
              fileUrl = fileUrl.replace(
                'https://private-user-attachments.githubusercontent.com/',
                'https://github.com/'
              );
            }
            
            // è·å–åŸå§‹æ–‡ä»¶å
            const urlObj = new URL(fileUrl, 'https://github.com');
            let originalName = decodeURIComponent(urlObj.pathname.split('/').pop());
            
            // é¢å¤–éªŒè¯ï¼šç¡®ä¿æ–‡ä»¶ååŒ…å«.jar.zip
            if (!originalName.toLowerCase().endsWith('.jar.zip')) {
              // å°è¯•ä»URLå‚æ•°è·å–åŸå§‹æ–‡ä»¶å
              const urlParams = new URLSearchParams(urlObj.search);
              if (urlParams.has('name')) {
                originalName = decodeURIComponent(urlParams.get('name'));
              }
              
              if (!originalName.toLowerCase().endsWith('.jar.zip')) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `âŒ æ— æ•ˆçš„æ–‡ä»¶åæ ¼å¼\n\nè¯·å°†æ–‡ä»¶é‡å‘½åä¸º **.jar.zip** åç¼€ï¼ˆä¾‹å¦‚ï¼šcoolmod.jar.zipï¼‰ã€‚\n\næ£€æµ‹åˆ°çš„æ–‡ä»¶å: \`${originalName}\``
                });
                await github.rest.issues.update({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed'
                });
                core.setFailed('Invalid filename format');
                return;
              }
            }
            
            // è·å–æ–‡ä»¶å¤§å°
            let contentLength = 0;
            try {
              const headers = { 
                'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`,
                'User-Agent': 'Mozilla/5.0 (compatible; GitHub-Actions)'
              };
              
              const response = await fetch(fileUrl, {
                method: 'HEAD',
                headers,
                redirect: 'follow'
              });
              
              console.log('HEAD request status:', response.status);
              console.log('Response headers:', Object.fromEntries(response.headers.entries()));
              
              if (response.ok) {
                contentLength = parseInt(response.headers.get('content-length') || '0');
              } else {
                // å¤‡ç”¨æ–¹æ³•ï¼šä»URLå‚æ•°è·å–
                const urlParams = new URLSearchParams(urlObj.search);
                if (urlParams.has('size')) {
                  contentLength = parseInt(urlParams.get('size') || '0');
                }
              }
            } catch (error) {
              console.log('è·å–æ–‡ä»¶å¤§å°å¤±è´¥ï¼Œå°†åœ¨ä¸‹è½½åéªŒè¯:', error.message);
            }
            
            // è®¾ç½®é»˜è®¤å€¼
            if (contentLength === 0) {
              console.log('æ— æ³•ç¡®å®šæ–‡ä»¶å¤§å°ï¼Œè®¾ä¸ºé»˜è®¤å€¼');
              contentLength = 1024; // 1KB
            }
            
            core.setOutput('file_url', fileUrl);
            core.setOutput('original_name', originalName);
            core.setOutput('jar_name', originalName.replace(/\.zip$/i, '.jar'));
            core.setOutput('file_size', contentLength);
            core.setOutput('debug_info', `Title: ${title}\nLabels: ${issue.labels.map(l => l.name).join(', ')}`);

      - name: Download attachment
        if: steps.validate_issue.outcome == 'success'
        env:
          FILE_URL: ${{ steps.validate_issue.outputs.file_url }}
          OUTPUT_NAME: ${{ steps.validate_issue.outputs.original_name }}
        run: |
          echo "å¼€å§‹ä¸‹è½½æ–‡ä»¶: $FILE_URL"
          echo "ä¿å­˜ä¸º: $OUTPUT_NAME"
          
          # ä½¿ç”¨wgetæ›´å¯é çš„ä¸‹è½½
          wget -nv \
            --header="Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            --header="Accept: application/octet-stream" \
            --retry-connrefused \
            --waitretry=1 \
            --timeout=300 \
            --tries=3 \
            -O "$OUTPUT_NAME" \
            "$FILE_URL"
          
          # éªŒè¯ä¸‹è½½ç»“æœ
          if [ ! -f "$OUTPUT_NAME" ]; then
            echo "âŒ æ–‡ä»¶ä¸‹è½½å¤±è´¥"
            exit 1
          fi
          
          actual_size=$(stat -c%s "$OUTPUT_NAME")
          echo "ä¸‹è½½å®Œæˆï¼Œæ–‡ä»¶å¤§å°: $actual_size å­—èŠ‚"

      - name: Verify file integrity
        id: verify_file
        if: steps.validate_issue.outcome == 'success'
        run: |
          FILE="${{ steps.validate_issue.outputs.original_name }}"
          
          # éªŒè¯æ–‡ä»¶å¤§å°
          actual_size=$(stat -c%s "$FILE")
          max_size=${{ env.MAX_FILE_SIZE }}
          
          echo "æ–‡ä»¶å¤§å°: $actual_size å­—èŠ‚"
          echo "æœ€å¤§å…è®¸: $max_size å­—èŠ‚"
          
          if [ "$actual_size" -gt "$max_size" ]; then
            echo "âŒ æ–‡ä»¶è¶…è¿‡${{ env.MAX_FILE_SIZE }}å­—èŠ‚é™åˆ¶"
            exit 1
          fi
          
          if [ "$actual_size" -eq 0 ]; then
            echo "âŒ ä¸‹è½½çš„æ–‡ä»¶ä¸ºç©º"
            exit 1
          fi
          
          # æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„ZIPæ–‡ä»¶
          if ! file "$FILE" | grep -qi 'zip'; then
            echo "âŒ æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„ZIPæ ¼å¼"
            echo "æ–‡ä»¶ç±»å‹æ£€æµ‹: $(file "$FILE")"
            exit 1
          fi
          
          # è®¡ç®—SHA256
          sha256=$(sha256sum "$FILE" | awk '{print $1}')
          echo "SHA256: $sha256"
          echo "sha256_hash=$sha256" >> $GITHUB_OUTPUT
          
          # éªŒè¯ZIPå®Œæ•´æ€§
          if ! unzip -t "$FILE" > /dev/null 2>&1; then
            echo "âŒ ZIPæ–‡ä»¶æŸåæˆ–æ— æ•ˆ"
            unzip -t "$FILE"  # è¾“å‡ºè¯¦ç»†é”™è¯¯
            exit 1
          fi

      - name: Check for duplicates
        id: check_duplicates
        if: steps.verify_file.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const sha256_hash = '${{ steps.verify_file.outputs.sha256_hash }}';
            const shortHash = sha256_hash.substring(0, 8);
            
            try {
              // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå“ˆå¸Œçš„Release
              const { data: release } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `sha256-${sha256_hash}`
              });
              
              // æŸ¥æ‰¾JARèµ„äº§
              const jarAsset = release.assets.find(asset => 
                asset.name.toLowerCase().endsWith('.jar')
              );
              
              if (jarAsset) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `ğŸ”„ æ£€æµ‹åˆ°é‡å¤æ–‡ä»¶\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨äºä»“åº“ä¸­:\nğŸ”— [ä¸‹è½½ç°æœ‰æ–‡ä»¶](${jarAsset.browser_download_url})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\`\n\næ— éœ€é‡å¤ä¸Šä¼ ï¼Œç›´æ¥ä½¿ç”¨ç°æœ‰æ–‡ä»¶å³å¯ã€‚`
                });
                await github.rest.issues.update({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed'
                });
                core.setOutput('duplicate', 'true');
                core.setOutput('existing_url', jarAsset.browser_download_url);
                core.setOutput('short_hash', shortHash);
                return;
              }
            } catch (error) {
              // 404è¡¨ç¤ºæ²¡æœ‰é‡å¤
              if (error.status !== 404) {
                console.log('æ£€æŸ¥é‡å¤æ–‡ä»¶æ—¶å‡ºé”™ï¼Œç»§ç»­å¤„ç†:', error.message);
              }
            }
            
            core.setOutput('duplicate', 'false');
            core.setOutput('short_hash', shortHash);

      - name: Rename to JAR
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.verify_file.outcome == 'success'
        run: |
          ORIGINAL="${{ steps.validate_issue.outputs.original_name }}"
          TARGET="${{ steps.validate_issue.outputs.jar_name }}"
          
          echo "é‡å‘½å: $ORIGINAL â†’ $TARGET"
          mv "$ORIGINAL" "$TARGET"
          
          # éªŒè¯é‡å‘½åç»“æœ
          if [ ! -f "$TARGET" ]; then
            echo "âŒ é‡å‘½åå¤±è´¥"
            exit 1
          fi

      - name: Create release
        id: create_release
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.verify_file.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { createReadStream } = require('fs');
            const { join } = require('path');
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const tagName = `sha256-${{ steps.verify_file.outputs.sha256_hash }}`;
            const releaseName = `Mod Upload (${timestamp}) - ${{ steps.check_duplicates.outputs.short_hash }}`;
            const jarFile = join(process.cwd(), '${{ steps.validate_issue.outputs.jar_name }}');
            const fileSize = fs.statSync(jarFile).size;
            
            console.log(`åˆ›å»ºRelease: ${releaseName}`);
            console.log(`æ–‡ä»¶å¤§å°: ${fileSize} å­—èŠ‚`);
            
            try {
              // æ£€æŸ¥releaseæ˜¯å¦å·²å­˜åœ¨ï¼ˆé˜²æ­¢å¹¶å‘é—®é¢˜ï¼‰
              try {
                await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tagName
                });
                console.log('Releaseå·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º');
                core.setFailed('Duplicate release detected');
                return;
              } catch (e) {
                if (e.status !== 404) throw e;
              }
              
              // åˆ›å»ºå¸¦å“ˆå¸Œæ ‡è®°çš„Release
              const { data: release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tagName,
                name: releaseName,
                body: `âœ… ä¸Šä¼ æˆåŠŸ\n\nğŸ“Œ åŸå§‹Issue: #${context.issue.number}\nğŸ”– å®Œæ•´å“ˆå¸Œ: ${{ steps.verify_file.outputs.sha256_hash }}\n\nâš ï¸ **æ³¨æ„**: åªæœ‰ä»“åº“ç®¡ç†å‘˜å¯åˆ é™¤æ­¤æ–‡ä»¶`,
                draft: false,
                prerelease: false
              });
              
              // ä¸Šä¼ JARæ–‡ä»¶
              const fileStream = createReadStream(jarFile);
              const { data: asset } = await github.rest.repos.uploadReleaseAsset({
                url: release.upload_url,
                headers: {
                  'content-length': fileSize,
                  'content-type': 'application/java-archive'
                },
                name: '${{ steps.validate_issue.outputs.jar_name }}',
                 fileStream
              });
              
              console.log('ä¸Šä¼ æˆåŠŸï¼Œèµ„äº§ID:', asset.id);
              core.setOutput('release_url', release.html_url);
              core.setOutput('download_url', asset.browser_download_url);
            } catch (error) {
              console.error('åˆ›å»ºReleaseå¤±è´¥:', error);
              if (error.message.includes('already_exists')) {
                core.setFailed('æ–‡ä»¶å·²å­˜åœ¨ï¼Œè¯·å‹¿é‡å¤ä¸Šä¼ ');
              } else {
                core.setFailed(`Releaseåˆ›å»ºå¤±è´¥: ${error.message || error}`);
              }
            }

      - name: Comment success
        if: steps.create_release.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = `${{ steps.create_release.outputs.download_url }}`;
            const releaseUrl = `${{ steps.create_release.outputs.release_url }}`;
            const shortHash = `${{ steps.check_duplicates.outputs.short_hash }}`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“¥ **æ–‡ä»¶**: \`${shortHash}...\`\nğŸ”— [ç›´æ¥ä¸‹è½½](${downloadUrl})\nğŸ“¦ [æŸ¥çœ‹Release](${releaseUrl})\n\nâ„¹ï¸ æ­¤æ–‡ä»¶å·²é€šè¿‡é‡å¤æ€§æ£€æŸ¥`
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Cleanup
        if: always()
        run: |
          echo "æ¸…ç†ä¸´æ—¶æ–‡ä»¶..."
          ls -la
          rm -f *.zip *.jar *.tmp || true
          echo "æ¸…ç†å®Œæˆ"

# .github/workflows/mod_uploader.yml
name: Mod File Uploader with Deduplication

on:
  issues:
    types: [opened]

env:
  MAX_FILE_SIZE: 524288000  # 500MB in bytes

jobs:
  process-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Validate issue structure
        id: validate_issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            // æ£€æŸ¥å¿…è¦æ ‡ç­¾
            if (!issue.labels.some(label => label.name === 'upload')) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'âŒ æ— æ•ˆçš„Issueç±»å‹\n\nè¯·ä½¿ç”¨"ä¸Šä¼ æ¨¡ç»„æ–‡ä»¶"æ¨¡æ¿åˆ›å»ºIssue'
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Missing required label');
              return;
            }
            
            // æå–é™„ä»¶URL
            const attachments = [...body.matchAll(/!\[[^\]]*\]\(([^)]+)\)/g)];
            if (attachments.length === 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æœªæ£€æµ‹åˆ°é™„ä»¶\n\nè¯·å°†.jaræ–‡ä»¶é‡å‘½åä¸º**.jar.zip**åä¸Šä¼ ï¼ˆä¾‹å¦‚ï¼šmod.jar â†’ mod.jar.zipï¼‰`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('No attachments found');
              return;
            }
            
            // è·å–ç¬¬ä¸€ä¸ªé™„ä»¶
            let fileUrl = attachments[0][1];
            const originalName = decodeURIComponent(fileUrl.split('/').pop().split('?')[0]);
            
            // éªŒè¯æ–‡ä»¶åæ ¼å¼
            if (!originalName.endsWith('.jar.zip')) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æ— æ•ˆçš„æ–‡ä»¶åæ ¼å¼\n\nè¯·å°†æ–‡ä»¶é‡å‘½åä¸º **.jar.zip** åç¼€ï¼ˆä¾‹å¦‚ï¼šcoolmod.jar.zipï¼‰`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid filename format');
              return;
            }
            
            // è·å–æ–‡ä»¶å¤§å°
            let contentLength = 0;
            try {
              const headers = { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}` };
              const response = await fetch(fileUrl.replace('private-user-attachments', 'github'), {
                method: 'HEAD',
                headers,
                redirect: 'follow'
              });
              
              if (response.ok) {
                contentLength = parseInt(response.headers.get('content-length') || '0');
              } else {
                // å¦‚æœHEADè¯·æ±‚å¤±è´¥ï¼Œå°è¯•è·å–æ–‡ä»¶å…ƒæ•°æ®
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number
                });
                
                const attachment = issueData.data.body.match(/!\[[^\]]*\]\(([^)]+\.zip)\)/);
                if (attachment) {
                  const attachmentUrl = attachment[1];
                  const attachmentResponse = await fetch(attachmentUrl, { headers });
                  contentLength = parseInt(attachmentResponse.headers.get('content-length') || '0');
                }
              }
            } catch (error) {
              console.log('æ— æ³•è·å–æ–‡ä»¶å¤§å°ï¼Œå°†åœ¨ä¸‹è½½åéªŒè¯:', error.message);
            }
            
            // å¦‚æœæ— æ³•è·å–å¤§å°ï¼Œè®¾ä¸ºæœ€å¤§å€¼å¼ºåˆ¶åç»­éªŒè¯
            if (contentLength === 0) contentLength = ${{ env.MAX_FILE_SIZE }} + 1;
            
            core.setOutput('file_url', fileUrl);
            core.setOutput('original_name', originalName);
            core.setOutput('jar_name', originalName.replace(/\.zip$/, ''));
            core.setOutput('file_size', contentLength);

      - name: Download attachment
        if: steps.validate_issue.outcome == 'success'
        env:
          FILE_URL: ${{ steps.validate_issue.outputs.file_url }}
          OUTPUT_NAME: ${{ steps.validate_issue.outputs.original_name }}
        run: |
          echo "Downloading file from $FILE_URL"
          curl -L \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/octet-stream" \
            --retry 3 \
            --retry-delay 5 \
            --max-time 300 \
            "$FILE_URL" \
            -o "$OUTPUT_NAME"

      - name: Verify file integrity
        id: verify_file
        if: steps.validate_issue.outcome == 'success'
        run: |
          # éªŒè¯æ–‡ä»¶å¤§å°
          actual_size=$(stat -c%s "${{ steps.validate_issue.outputs.original_name }}")
          expected_size=${{ steps.validate_issue.outputs.file_size }}
          
          echo "å®é™…å¤§å°: $actual_size å­—èŠ‚"
          echo "é¢„æœŸå¤§å°: $expected_size å­—èŠ‚"
          
          if [ "$actual_size" -gt "${{ env.MAX_FILE_SIZE }}" ]; then
            echo "âŒ æ–‡ä»¶è¶…è¿‡500MBé™åˆ¶"
            exit 1
          fi
          
          if [ "$actual_size" -eq 0 ]; then
            echo "âŒ ä¸‹è½½çš„æ–‡ä»¶ä¸ºç©º"
            exit 1
          fi
          
          # è®¡ç®—SHA256
          sha256=$(sha256sum "${{ steps.validate_issue.outputs.original_name }}" | awk '{print $1}')
          echo "SHA256: $sha256"
          echo "sha256_hash=$sha256" >> $GITHUB_OUTPUT
          
          # éªŒè¯æ–‡ä»¶æ˜¯å¦ä¸ºæœ‰æ•ˆZIP
          if ! unzip -t "${{ steps.validate_issue.outputs.original_name }}" > /dev/null 2>&1; then
            echo "âŒ æ— æ•ˆçš„ZIPæ–‡ä»¶"
            exit 1
          fi

      - name: Check for duplicates
        id: check_duplicates
        if: steps.verify_file.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const { sha256_hash } = ${{ toJSON(steps.verify_file.outputs) }};
            const shortHash = sha256_hash.substring(0, 8);
            
            try {
              // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå“ˆå¸Œçš„Release
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `sha256-${sha256_hash}`
              });
              
              // å¦‚æœå­˜åœ¨ï¼Œè·å–ä¸‹è½½é“¾æ¥
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 50
              });
              
              const duplicateRelease = releases.data.find(r => r.tag_name === `sha256-${sha256_hash}`);
              if (duplicateRelease) {
                const asset = duplicateRelease.assets.find(a => a.name.endsWith('.jar'));
                if (asset) {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: `ğŸ”„ æ£€æµ‹åˆ°é‡å¤æ–‡ä»¶\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨äºä»“åº“ä¸­:\nğŸ”— [ä¸‹è½½ç°æœ‰æ–‡ä»¶](${asset.browser_download_url})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\`\n\næ— éœ€é‡å¤ä¸Šä¼ ï¼Œç›´æ¥ä½¿ç”¨ç°æœ‰æ–‡ä»¶å³å¯ã€‚`
                  });
                  await github.rest.issues.update({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'closed'
                  });
                  core.setOutput('duplicate', 'true');
                  core.setOutput('existing_url', asset.browser_download_url);
                  return;
                }
              }
            } catch (error) {
              // 404è¡¨ç¤ºæ²¡æœ‰é‡å¤
              if (error.status !== 404) {
                console.log('æ£€æŸ¥é‡å¤æ–‡ä»¶æ—¶å‡ºé”™:', error.message);
              }
            }
            
            core.setOutput('duplicate', 'false');
            core.setOutput('short_hash', shortHash);

      - name: Rename to JAR
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.verify_file.outcome == 'success'
        run: |
          mv "${{ steps.validate_issue.outputs.original_name }}" "${{ steps.validate_issue.outputs.jar_name }}"

      - name: Create release
        id: create_release
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.verify_file.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { createReadStream } = require('fs');
            const { join } = require('path');
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const tagName = `sha256-${{ steps.verify_file.outputs.sha256_hash }}`;
            const releaseName = `Mod Upload (${timestamp}) - ${{ steps.check_duplicates.outputs.short_hash }}`;
            const jarFile = join(process.cwd(), '${{ steps.validate_issue.outputs.jar_name }}');
            const fileSize = fs.statSync(jarFile).size;
            
            try {
              // åˆ›å»ºå¸¦å“ˆå¸Œæ ‡è®°çš„Release
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tagName,
                name: releaseName,
                body: `âœ… ä¸Šä¼ æˆåŠŸ\n\nğŸ“Œ åŸå§‹Issue: #${context.issue.number}\nğŸ”– å®Œæ•´å“ˆå¸Œ: ${{ steps.verify_file.outputs.sha256_hash }}\n\nâš ï¸ **æ³¨æ„**: åªæœ‰ä»“åº“ç®¡ç†å‘˜å¯åˆ é™¤æ­¤æ–‡ä»¶`,
                draft: false,
                prerelease: false
              });
              
              // ä¸Šä¼ JARæ–‡ä»¶
              const fileStream = createReadStream(jarFile);
              const asset = await github.rest.repos.uploadReleaseAsset({
                url: release.data.upload_url,
                headers: {
                  'content-length': fileSize,
                  'content-type': 'application/java-archive'
                },
                name: '${{ steps.validate_issue.outputs.jar_name }}',
                 fileStream
              });
              
              core.setOutput('release_url', release.data.html_url);
              core.setOutput('download_url', asset.data.browser_download_url);
            } catch (error) {
              console.error('åˆ›å»ºReleaseå¤±è´¥:', error);
              core.setFailed(`Releaseåˆ›å»ºå¤±è´¥: ${error.message}`);
            }

      - name: Comment success
        if: steps.create_release.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = `${{ steps.create_release.outputs.download_url }}`;
            const releaseUrl = `${{ steps.create_release.outputs.release_url }}`;
            const shortHash = `${{ steps.check_duplicates.outputs.short_hash }}`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“¥ **æ–‡ä»¶**: \`${shortHash}...\`\nğŸ”— [ç›´æ¥ä¸‹è½½](${downloadUrl})\nğŸ“¦ [æŸ¥çœ‹Release](${releaseUrl})\n\nâ„¹ï¸ æ­¤æ–‡ä»¶å·²é€šè¿‡é‡å¤æ€§æ£€æŸ¥`
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Cleanup
        if: always()
        run: |
          echo "æ¸…ç†ä¸´æ—¶æ–‡ä»¶..."
          rm -f *.zip *.jar || true
          echo "æ¸…ç†å®Œæˆ"

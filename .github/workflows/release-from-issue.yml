# .github/workflows/mod_uploader.yml
name: Mod File Uploader with Deduplication

on:
  issues:
    types: [opened]

env:
  # æœ€å¤§æ–‡ä»¶å¤§å° (500MB)
  MAX_FILE_SIZE: 524288000
  # ç—…æ¯’æ‰«æå¼•æ“
  CLAMAV_DATABASE: daily

jobs:
  process-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      actions: read

    steps:
      - name: Validate issue structure
        id: validate_issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            // æ£€æŸ¥å¿…è¦æ ‡ç­¾
            if (!issue.labels.some(label => label.name === 'upload')) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'âŒ æ— æ•ˆçš„Issueç±»å‹\n\nè¯·ä½¿ç”¨"Upload Mod File"æ¨¡æ¿åˆ›å»ºIssue'
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Missing required label');
              return;
            }
            
            // æ£€æŸ¥é™„ä»¶
            const zipAttachments = body.match(/!\[[^\]]*\]\(([^)]+\.zip)\)/g) || [];
            if (zipAttachments.length === 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æœªæ£€æµ‹åˆ°é™„ä»¶\n\nè¯·å°†.jaræ–‡ä»¶é‡å‘½åä¸º**.jar.zip**åä¸Šä¼ ï¼ˆä¾‹å¦‚ï¼šmod.jar â†’ mod.jar.zipï¼‰`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('No attachments found');
              return;
            }
            
            // æå–ç¬¬ä¸€ä¸ªæœ‰æ•ˆURL
            const match = zipAttachments[0].match(/\(([^)]+\.zip)\)/);
            let fileUrl = match[1];
            
            // å¤„ç†GitHubçš„é™„ä»¶ä»£ç†URL
            if (fileUrl.includes('private-user-attachments')) {
              fileUrl = fileUrl.replace('https://private-user-attachments.githubusercontent.com/', 'https://github.com/');
            }
            
            const originalName = decodeURIComponent(fileUrl.split('/').pop().split('?')[0]);
            
            // éªŒè¯æ–‡ä»¶åæ ¼å¼
            if (!originalName.endsWith('.jar.zip')) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æ— æ•ˆçš„æ–‡ä»¶åæ ¼å¼\n\nè¯·å°†æ–‡ä»¶é‡å‘½åä¸º **.jar.zip** åç¼€ï¼ˆä¾‹å¦‚ï¼šcoolmod.jar.zipï¼‰`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid filename format');
              return;
            }
            
            // éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆé€šè¿‡HEADè¯·æ±‚ï¼‰
            const headers = { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}` };
            const headResponse = await fetch(fileUrl, { method: 'HEAD', headers });
            const contentLength = parseInt(headResponse.headers.get('content-length') || '0');
            
            if (contentLength === 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'âŒ æ— æ³•è·å–æ–‡ä»¶å¤§å°\n\nè¯·é‡æ–°ä¸Šä¼ æ–‡ä»¶'
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Failed to get file size');
              return;
            }
            
            if (contentLength > ${{ env.MAX_FILE_SIZE }}) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æ–‡ä»¶è¿‡å¤§\n\næœ€å¤§å…è®¸500MBï¼Œæ‚¨çš„æ–‡ä»¶: ${(contentLength / 1024 / 1024).toFixed(2)}MB`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('File too large');
              return;
            }
            
            core.setOutput('file_url', fileUrl);
            core.setOutput('original_name', originalName);
            core.setOutput('jar_name', originalName.replace(/\.zip$/, ''));
            core.setOutput('file_size', contentLength);

      - name: Download attachment
        if: steps.validate_issue.outcome == 'success'
        env:
          FILE_URL: ${{ steps.validate_issue.outputs.file_url }}
          OUTPUT_NAME: ${{ steps.validate_issue.outputs.original_name }}
        run: |
          echo "Downloading file from $FILE_URL"
          curl -L \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/octet-stream" \
            "$FILE_URL" \
            --output "$OUTPUT_NAME" \
            --max-time 300 \
            --retry 3 \
            --retry-delay 5

      - name: Verify file integrity
        if: steps.validate_issue.outcome == 'success'
        id: verify_file
        run: |
          # éªŒè¯å®é™…ä¸‹è½½å¤§å°
          actual_size=$(stat -c%s "$1")
          expected_size=${{ steps.validate_issue.outputs.file_size }}
          
          if [ "$actual_size" != "$expected_size" ]; then
            echo "âŒ æ–‡ä»¶å¤§å°ä¸åŒ¹é…"
            echo "é¢„æœŸ: $expected_size å­—èŠ‚"
            echo "å®é™…: $actual_size å­—èŠ‚"
            exit 1
          fi
          
          # è®¡ç®—SHA256
          sha256=$(sha256sum "${{ steps.validate_issue.outputs.original_name }}" | awk '{print $1}')
          echo "SHA256: $sha256"
          echo "sha256_hash=$sha256" >> $GITHUB_OUTPUT
        env:
          FILE: ${{ steps.validate_issue.outputs.original_name }}

      - name: Check for duplicates
        id: check_duplicates
        if: steps.verify_file.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const { sha256_hash } = ${{ toJSON(steps.verify_file.outputs) }};
            const shortHash = sha256_hash.substring(0, 8);
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå“ˆå¸Œçš„Release
            try {
              const response = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `sha256-${sha256_hash}`
              });
              
              // å¦‚æœå­˜åœ¨ï¼Œè·å–ä¸‹è½½é“¾æ¥
              const asset = response.data.assets.find(a => a.name.endsWith('.jar'));
              if (asset) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `ğŸ”„ æ£€æµ‹åˆ°é‡å¤æ–‡ä»¶\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨äºä»“åº“ä¸­:\n[ä¸‹è½½é“¾æ¥](${asset.browser_download_url})\n\nå“ˆå¸Œå€¼: \`${shortHash}...\``
                });
                await github.rest.issues.update({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed'
                });
                core.setOutput('duplicate', 'true');
                core.setOutput('existing_url', asset.browser_download_url);
                return;
              }
            } catch (error) {
              // 404è¡¨ç¤ºæ²¡æœ‰é‡å¤
              if (error.status !== 404) {
                console.error('Error checking duplicates:', error);
              }
            }
            
            core.setOutput('duplicate', 'false');
            core.setOutput('short_hash', shortHash);

      - name: Virus scan with ClamAV
        if: steps.check_duplicates.outputs.duplicate == 'false'
        uses: crazy-max/ghaction-clamav@v2
        with:
          database: ${{ env.CLAMAV_DATABASE }}
          path: ${{ steps.validate_issue.outputs.original_name }}
          ignore-warnings: true

      - name: Rename to JAR
        if: steps.check_duplicates.outputs.duplicate == 'false' && steps.verify_file.outcome == 'success'
        run: |
          mv "${{ steps.validate_issue.outputs.original_name }}" "${{ steps.validate_issue.outputs.jar_name }}"

      - name: Create release
        id: create_release
        if: steps.check_duplicates.outputs.duplicate == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { createReadStream } = require('fs');
            const { join } = require('path');
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const tagName = `sha256-${{ steps.verify_file.outputs.sha256_hash }}`;
            const releaseName = `Mod Upload (${timestamp}) - ${{ steps.check_duplicates.outputs.short_hash }}`;
            const jarFile = join(process.cwd(), '${{ steps.validate_issue.outputs.jar_name }}');
            const fileSize = fs.statSync(jarFile).size;
            
            // åˆ›å»ºå¸¦å“ˆå¸Œæ ‡è®°çš„Release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: releaseName,
              body: `âœ… å®‰å…¨éªŒè¯é€šè¿‡\n\nğŸ“Œ åŸå§‹Issue: #${context.issue.number}\nğŸ”– å®Œæ•´å“ˆå¸Œ: ${{ steps.verify_file.outputs.sha256_hash }}\n\nâš ï¸ **æ³¨æ„**: åªæœ‰ä»“åº“ç®¡ç†å‘˜å¯åˆ é™¤æ­¤æ–‡ä»¶`,
              draft: false,
              prerelease: false
            });
            
            // ä¸Šä¼ JARæ–‡ä»¶
            const fileStream = createReadStream(jarFile);
            const asset = await github.rest.repos.uploadReleaseAsset({
              url: release.data.upload_url,
              headers: {
                'content-length': fileSize,
                'content-type': 'application/java-archive'
              },
              name: '${{ steps.validate_issue.outputs.jar_name }}',
              data: fileStream
            });
            
            core.setOutput('release_url', release.data.html_url);
            core.setOutput('download_url', asset.data.browser_download_url);

      - name: Comment success
        if: steps.create_release.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = `${{ steps.create_release.outputs.download_url }}`;
            const releaseUrl = `${{ steps.create_release.outputs.release_url }}`;
            const shortHash = `${{ steps.check_duplicates.outputs.short_hash }}`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“¥ **æ–‡ä»¶**: \`${shortHash}...\`\nğŸ”— [ç›´æ¥ä¸‹è½½](${downloadUrl})\nğŸ“¦ [æŸ¥çœ‹Release](${releaseUrl})\n\nâ„¹ï¸ æ­¤æ–‡ä»¶å·²é€šè¿‡ç—…æ¯’æ‰«æå’Œé‡å¤æ€§æ£€æŸ¥`
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Comment duplicate
        if: steps.check_duplicates.outputs.duplicate == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const existingUrl = `${{ steps.check_duplicates.outputs.existing_url }}`;
            const shortHash = `${{ steps.check_duplicates.outputs.short_hash }}`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ğŸ”„ æ£€æµ‹åˆ°é‡å¤æ–‡ä»¶\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨äºä»“åº“ä¸­:\nğŸ”— [ä¸‹è½½ç°æœ‰æ–‡ä»¶](${existingUrl})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\`\n\næ— éœ€é‡å¤ä¸Šä¼ ï¼Œç›´æ¥ä½¿ç”¨ç°æœ‰æ–‡ä»¶å³å¯ã€‚`
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Cleanup
        if: always()
        run: |
          echo "æ¸…ç†ä¸´æ—¶æ–‡ä»¶..."
          rm -f *.zip *.jar || true
          echo "æ¸…ç†å®Œæˆ"

# .github/workflows/mod_uploader.yml
name: Mod File Uploader with Deduplication

on:
  issues:
    types: [opened]

env:
  MAX_FILE_SIZE: 524288000  # 500MB

jobs:
  process-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Validate issue structure
        id: validate_issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            
            // 1. éªŒè¯Issueç±»å‹
            const hasValidTitle = title.trim().startsWith('[UPLOAD]');
            const hasTemplateContent = body.includes('é‡è¦æç¤º') && body.includes('é‡å‘½åä¸º **.jar.zip**');
            
            console.log(`æ ‡é¢˜æœ‰æ•ˆ: ${hasValidTitle}, æ¨¡æ¿å†…å®¹æœ‰æ•ˆ: ${hasTemplateContent}`);
            
            if (!(hasValidTitle || hasTemplateContent)) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æœªä½¿ç”¨æ­£ç¡®çš„æ¨¡æ¿\n\nè¯·**åŠ¡å¿…**é€šè¿‡ä»¥ä¸‹æ­¥éª¤åˆ›å»º:\n1. ç‚¹å‡»"Issues" â†’ "New Issue"\n2. **é€‰æ‹©"ä¸Šä¼ æ¨¡ç»„æ–‡ä»¶"æ¨¡æ¿** (ä¸æ˜¯ç©ºç™½æ¨¡æ¿)\n3. æŒ‰ç…§æ¨¡æ¿æŒ‡å¼•æ“ä½œ`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid template usage');
              return;
            }
            
            // 2. æå–é™„ä»¶ - ä¿®å¤æ­£åˆ™è¡¨è¾¾å¼ (æ·»åŠ gæ ‡å¿—)
            const attachmentRegex = /!\[[^\]]*\]\(([^)]+?\.zip(?:[^)]*)?)\)/ig; // å…³é”®ä¿®å¤: æ·»åŠ gæ ‡å¿—
            const attachments = [...body.matchAll(attachmentRegex)];
            console.log(`æ‰¾åˆ° ${attachments.length} ä¸ªé™„ä»¶`);
            
            if (attachments.length === 0) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æœªæ£€æµ‹åˆ°æœ‰æ•ˆçš„.zipé™„ä»¶\n\n**æ­£ç¡®æ“ä½œ**:\n1. å°†æ–‡ä»¶é‡å‘½åä¸º \`æ–‡ä»¶å.jar.zip\`\n2. **ç›´æ¥æ‹–æ‹½**æ–‡ä»¶åˆ°è¯„è®ºæ¡† (ç­‰å¾…ä¸Šä¼ å®Œæˆ)\n3. ç¡®ä¿é™„ä»¶æ˜¾ç¤ºä¸ºé“¾æ¥ (å¦‚: \`![æ–‡ä»¶å.jar.zip](https://...)\`)`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('No valid zip attachment');
              return;
            }
            
            // 3. å¤„ç†ç¬¬ä¸€ä¸ªé™„ä»¶
            let fileUrl = attachments[0][1];
            console.log('åŸå§‹é™„ä»¶URL:', fileUrl);
            
            // ä¿®å¤GitHubç§æœ‰é™„ä»¶URL
            fileUrl = fileUrl.replace(
              'https://private-user-attachments.githubusercontent.com/',
              'https://github.com/'
            );
            
            // 4. å¤„ç†ç‰¹æ®Šå­—ç¬¦ (å¦‚+å·)
            fileUrl = fileUrl.replace(/%2B/g, '+').replace(/%20/g, ' ');
            console.log('å¤„ç†åURL:', fileUrl);
            
            // 5. æå–æ–‡ä»¶å
            let originalName = '';
            try {
              // ä»URLå‚æ•°è·å–åŸå§‹æ–‡ä»¶å
              if (fileUrl.includes('?')) {
                const urlParams = new URLSearchParams(fileUrl.split('?')[1]);
                if (urlParams.has('name')) {
                  originalName = decodeURIComponent(urlParams.get('name'));
                }
              }
              
              // ä»è·¯å¾„æå–
              if (!originalName) {
                const path = new URL(fileUrl, 'https://github.com').pathname;
                originalName = decodeURIComponent(path.split('/').pop());
              }
            } catch (e) {
              console.log('URLè§£æå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•');
              // ä»URLå­—ç¬¦ä¸²æå–
              const match = fileUrl.match(/\/([^\/?]+?)(?:\?|$)/i);
              originalName = match ? decodeURIComponent(match[1].replace(/\+/g, ' ')) : 'unknown.zip';
            }
            
            console.log('æå–çš„æ–‡ä»¶å:', originalName);
            
            // 6. æ™ºèƒ½æ–‡ä»¶åéªŒè¯
            const lowerName = originalName.toLowerCase();
            let isValidFormat = false;
            let cleanedName = originalName;
            
            if (lowerName.includes('.jar.zip')) {
              isValidFormat = true;
              // ä¿®å¤ä¸å®Œæ•´åç¼€
              if (!lowerName.endsWith('.jar.zip')) {
                const base = originalName.split('.jar.zip')[0];
                cleanedName = base + '.jar.zip';
              }
            } else if (lowerName.endsWith('.zip')) {
              // å°è¯•æ™ºèƒ½ä¿®å¤
              if (lowerName.includes('.jar')) {
                isValidFormat = true;
                cleanedName = originalName.replace(/\.zip$/i, '.jar.zip');
              }
            }
            
            if (!isValidFormat) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âŒ æ— æ•ˆçš„æ–‡ä»¶åæ ¼å¼\n\n**å¿…é¡»åŒ…å« \`.jar.zip\`**\n\næ£€æµ‹åˆ°çš„æ–‡ä»¶å: \`${originalName}\`\n\nâœ… æ­£ç¡®ç¤ºä¾‹: \`modname-1.0.jar.zip\`\nâŒ é”™è¯¯ç¤ºä¾‹: \`modname.zip\` (ç¼ºå°‘.jar)`
              });
              await github.rest.issues.update({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed'
              });
              core.setFailed('Invalid filename format');
              return;
            }
            
            // 7. è·å–æ–‡ä»¶å¤§å°
            let contentLength = 0;
            try {
              const headers = { 
                'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`,
                'User-Agent': 'Mozilla/5.0 (compatible; GitHub-Actions)'
              };
              
              const response = await fetch(fileUrl, {
                method: 'HEAD',
                headers,
                redirect: 'follow'
              });
              
              if (response.ok) {
                contentLength = parseInt(response.headers.get('content-length') || '0');
                console.log('æ–‡ä»¶å¤§å°(HEAD):', contentLength);
              }
            } catch (error) {
              console.log('HEADè¯·æ±‚å¤±è´¥:', error.message);
            }
            
            // è®¾ç½®è¾“å‡º
            core.setOutput('file_url', fileUrl);
            core.setOutput('original_name', cleanedName);
            core.setOutput('jar_name', cleanedName.replace(/\.zip$/i, '.jar'));
            core.setOutput('file_size', contentLength || 1024); // é»˜è®¤1KB
            core.setOutput('is_valid_format', 'true');

      - name: Download attachment
        if: steps.validate_issue.outputs.is_valid_format == 'true'
        env:
          FILE_URL: ${{ steps.validate_issue.outputs.file_url }}
          OUTPUT_NAME: ${{ steps.validate_issue.outputs.original_name }}
        run: |
          echo "ä¸‹è½½æ–‡ä»¶: $FILE_URL"
          echo "ä¿å­˜ä¸º: $OUTPUT_NAME"
          
          # åˆ›å»ºå®‰å…¨çš„ä¸´æ—¶æ–‡ä»¶å
          TEMP_NAME="upload_temp_$(date +%s).zip"
          echo "ä¸´æ—¶æ–‡ä»¶å: $TEMP_NAME"
          
          # ä½¿ç”¨curlä¸‹è½½ (å…¼å®¹æ‰€æœ‰ç¯å¢ƒ)
          curl -L \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/octet-stream" \
            --retry 3 \
            --retry-delay 5 \
            --max-time 300 \
            -o "$TEMP_NAME" \
            "$FILE_URL"
          
          # éªŒè¯ä¸‹è½½
          if [ ! -f "$TEMP_NAME" ]; then
            echo "âŒ æ–‡ä»¶ä¸‹è½½å¤±è´¥"
            ls -la
            exit 1
          fi
          
          actual_size=$(stat -c%s "$TEMP_NAME")
          echo "ä¸‹è½½å®Œæˆï¼Œå¤§å°: $actual_size å­—èŠ‚"
          
          # é‡å‘½åå›åŸå§‹æ–‡ä»¶å
          mv "$TEMP_NAME" "$OUTPUT_NAME"

      - name: Verify file integrity
        id: verify_file
        if: steps.validate_issue.outputs.is_valid_format == 'true'
        run: |
          FILE="${{ steps.validate_issue.outputs.original_name }}"
          
          # éªŒè¯æ–‡ä»¶å¤§å°
          actual_size=$(stat -c%s "$FILE")
          max_size=${{ env.MAX_FILE_SIZE }}
          
          echo "æ–‡ä»¶å¤§å°: $actual_size å­—èŠ‚ (é™åˆ¶: $max_size)"
          
          if [ "$actual_size" -eq 0 ]; then
            echo "âŒ æ–‡ä»¶ä¸ºç©º"
            exit 1
          fi
          
          if [ "$actual_size" -gt "$max_size" ]; then
            echo "âŒ æ–‡ä»¶è¶…è¿‡500MBé™åˆ¶"
            exit 1
          fi
          
          # éªŒè¯ZIPå®Œæ•´æ€§
          if ! unzip -t "$FILE" > /dev/null 2>&1; then
            echo "âŒ ZIPæ–‡ä»¶æŸåæˆ–æ— æ•ˆ"
            unzip -t "$FILE" 2>&1
            exit 1
          fi
          
          # è®¡ç®—SHA256
          sha256=$(sha256sum "$FILE" | awk '{print $1}')
          echo "SHA256: $sha256"
          echo "sha256_hash=$sha256" >> $GITHUB_OUTPUT

      - name: Check for duplicates
        id: check_duplicates
        if: steps.verify_file.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const sha256_hash = '${{ steps.verify_file.outputs.sha256_hash }}';
            const shortHash = sha256_hash.substring(0, 8);
            
            try {
              // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå“ˆå¸Œçš„Release
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `sha256-${sha256_hash}`
              });
              
              // è·å–ç°æœ‰Release
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 50
              });
              
              const duplicateRelease = releases.data.find(r => r.tag_name === `sha256-${sha256_hash}`);
              if (duplicateRelease) {
                const jarAsset = duplicateRelease.assets.find(a => 
                  a.name.toLowerCase().endsWith('.jar')
                );
                
                if (jarAsset) {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: `ğŸ”„ **é‡å¤æ–‡ä»¶**\n\næ­¤æ–‡ä»¶å·²å­˜åœ¨:\nğŸ”— [ä¸‹è½½ç°æœ‰æ–‡ä»¶](${jarAsset.browser_download_url})\nğŸ”– å“ˆå¸Œ: \`${shortHash}...\`\n\næ— éœ€é‡å¤ä¸Šä¼ `
                  });
                  await github.rest.issues.update({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'closed'
                  });
                  core.setOutput('duplicate', 'true');
                  core.setOutput('existing_url', jarAsset.browser_download_url);
                  core.setOutput('short_hash', shortHash);
                  return;
                }
              }
            } catch (error) {
              if (error.status !== 404) {
                console.log('æ£€æŸ¥é‡å¤æ—¶å‡ºé”™ï¼Œç»§ç»­:', error.message);
              }
            }
            
            core.setOutput('duplicate', 'false');
            core.setOutput('short_hash', shortHash);

      - name: Rename to JAR
        if: steps.check_duplicates.outputs.duplicate == 'false'
        run: |
          ORIGINAL="${{ steps.validate_issue.outputs.original_name }}"
          TARGET="${{ steps.validate_issue.outputs.jar_name }}"
          
          echo "é‡å‘½å: $ORIGINAL â†’ $TARGET"
          mv "$ORIGINAL" "$TARGET"
          
          if [ ! -f "$TARGET" ]; then
            echo "âŒ é‡å‘½åå¤±è´¥"
            ls -la
            exit 1
          fi

      - name: Create release
        id: create_release
        if: steps.check_duplicates.outputs.duplicate == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { createReadStream } = require('fs');
            const { basename } = require('path');
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const tagName = `sha256-${{ steps.verify_file.outputs.sha256_hash }}`;
            const releaseName = `Mod (${timestamp}) - ${{ steps.check_duplicates.outputs.short_hash }}`;
            const jarFile = '${{ steps.validate_issue.outputs.jar_name }}';
            const fileSize = fs.statSync(jarFile).size;
            const jarName = basename(jarFile);
            
            try {
              // æ£€æŸ¥releaseæ˜¯å¦å·²å­˜åœ¨
              try {
                await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tagName
                });
                core.setFailed('æ–‡ä»¶å·²å­˜åœ¨');
                return;
              } catch (e) {
                if (e.status !== 404) throw e;
              }
              
              // åˆ›å»ºRelease
              const {  release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tagName,
                name: releaseName,
                body: `âœ… æ¥è‡ª Issue #${context.issue.number}\nğŸ”– SHA256: ${{ steps.verify_file.outputs.sha256_hash }}\n\nâš ï¸ ä»…ç®¡ç†å‘˜å¯åˆ é™¤`,
                draft: false,
                prerelease: false
              });
              
              // ä¸Šä¼ æ–‡ä»¶
              const asset = await github.rest.repos.uploadReleaseAsset({
                url: release.upload_url,
                headers: {
                  'content-length': fileSize,
                  'content-type': 'application/java-archive'
                },
                name: jarName,
                 createReadStream(jarFile)
              });
              
              core.setOutput('release_url', release.html_url);
              core.setOutput('download_url', asset.browser_download_url);
            } catch (error) {
              console.error('åˆ›å»ºReleaseå¤±è´¥:', error);
              core.setFailed(`ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
            }

      - name: Comment success
        if: steps.create_release.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **ä¸Šä¼ æˆåŠŸ!**\n\nğŸ“¥ [ä¸‹è½½æ–‡ä»¶](${{ steps.create_release.outputs.download_url }})\nğŸ“¦ [æŸ¥çœ‹æ‰€æœ‰æ–‡ä»¶](${{ steps.create_release.outputs.release_url }})\n\nâ„¹ï¸ å“ˆå¸Œ: \`${{ steps.check_duplicates.outputs.short_hash }}...\``
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });

      - name: Cleanup
        if: always()
        run: |
          echo "æ¸…ç†æ–‡ä»¶..."
          rm -f *.zip *.jar || true
          rm -f *.tmp || true
          echo "æ¸…ç†å®Œæˆ"
